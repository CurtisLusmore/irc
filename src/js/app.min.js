/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _Client = __webpack_require__(1);
	
	var _Client2 = _interopRequireDefault(_Client);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	(function () {
	    new _Client2.default(document.getElementById('app'));
	})();

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _IrcClient = __webpack_require__(2);
	
	var _IrcClient2 = _interopRequireDefault(_IrcClient);
	
	var _helpers = __webpack_require__(4);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	/**
	 * Class representing a form-backed IRC client.
	 */
	
	var Client = function () {
	    /**
	     * Create a new client and the form that provides its input and output.
	     * @param {container} The container element to add the form to.
	     */
	
	    function Client(container) {
	        var _this = this;
	
	        _classCallCheck(this, Client);
	
	        console.log('shit');
	        var form = document.createElement('form');
	        form.className = 'client';
	        var output = document.createElement('div');
	        output.className = 'client-output';
	        output.disabled = true;
	        form.appendChild(output);
	        var input = document.createElement('input');
	        input.className = 'client-input';
	        input.autofocus = true;
	        input.placeholder = 'JOIN #channel';
	        form.appendChild(input);
	        form.onsubmit = function () {
	            return _this.sendMessage();
	        };
	        container.appendChild(form);
	
	        var client = new _IrcClient2.default('chat.freenode.net', 6667);
	        client.subscribe('PING', function (msg) {
	            client.sendCommand('PONG', msg);
	        }).subscribe('NOTICE', function (msg) {
	            var res = (0, _helpers.split)(msg);
	            var recipient = res[0];
	            var message = res[1].substring(1);
	            _this.writeMessage(message);
	        })
	        // .subscribe(['001', '002', '003'], msg => { // Welcome
	        //     var res = split(msg);
	        //     var message = res[1].substring(1);
	        //     this.writeMessage(message);
	        // })
	        // .subscribe(['004', '005'], msg => { // info
	        //     var res = split(msg);
	        //     var message = res[1];
	        //     this.writeMessage(message);
	        // })
	        .subscribe(['353', '366'], function (msg) {
	            // NAMES
	            var res = (0, _helpers.split)(msg, ' ', 2);
	            var message = res[2];
	            _this.writeMessage(message);
	        }).subscribe(['432', '433', '451'], function (msg) {
	            // ERR_NICKNAMEINUSE
	            var res = (0, _helpers.split)(msg);
	            var message = res[1];
	            _this.writeMessage(message);
	        }).subscribe(['704', '705', '706'], function (msg) {
	            // HELP
	            var res = (0, _helpers.split)(msg, ' ', 2);
	            var msg = res[2].substring(1).trim();
	            if (msg !== '') _this.writeMessage(msg);
	        }).subscribe('QUIT', function (msg, pre) {
	            var user = (0, _helpers.makeUser)(pre);
	            _this.writeMessage(user.span, ' has quit: ' + msg.substring(1));
	        }).subscribe('JOIN', function (msg, pre) {
	            var user = (0, _helpers.makeUser)(pre);
	            _this.writeMessage(user.span, ' has joined ' + msg);
	        }).subscribe('PART', function (msg, pre) {
	            var user = (0, _helpers.makeUser)(pre);
	            _this.writeMessage(user.span, ' has left ' + msg);
	        }).subscribe('NICK', function (msg, pre) {
	            var user = (0, _helpers.makeUser)(pre);
	            _this.writeMessage(user.span, ' has changed nicknames to ' + msg);
	        }).subscribe('PRIVMSG', function (msg, pre) {
	            var res = (0, _helpers.split)(msg);
	            var channel = res[0];
	            var message = res[1].substring(1);
	            var user = (0, _helpers.makeUser)(pre);
	            _this.writeMessage(channel + ': ', user.span, ': ' + message);
	        });
	        client.sendCommand('PASS', 'curtispassword').sendCommand('NICK', 'curtis52').sendCommand('USER', 'curtis52', '0', '*', 'curtis');
	
	        this.form = form;
	        this.input = input;
	        this.output = output;
	        this.client = client;
	    }
	
	    /**
	     * Send a message to the IRC server.
	     * @param {arguments} The components of the message to send.
	     */
	
	
	    _createClass(Client, [{
	        key: 'sendMessage',
	        value: function sendMessage() {
	            var message = this.input.value;
	            this.input.value = '';
	
	            this.client.sendMessage(message);
	            return false;
	        }
	
	        /**
	         * Write a message to the form output. Adds all arguments to a container
	         * element which represents a single message.
	         * @param {arguments} The components of the message.
	         */
	
	    }, {
	        key: 'writeMessage',
	        value: function writeMessage() {
	            if (arguments.length === 1 && arguments[0] === '') {
	                console.log('empty');
	            }
	            var elem = document.createElement('div');
	            for (var ind in arguments) {
	                var argument = arguments[ind];
	                elem.appendChild(argument instanceof HTMLElement ? argument : document.createTextNode(argument));
	            }
	            return this.writeElement(elem);
	        }
	
	        /**
	         * Write a HTML element to the form output.
	         * @param {elem} A HTML element.
	         */
	
	    }, {
	        key: 'writeElement',
	        value: function writeElement(elem) {
	            var scrollToBottom = this.output.scrollTop + this.output.clientHeight + 1 >= this.output.scrollHeight;
	
	            var container = document.createElement('div');
	            container.className = 'client-message';
	            var date = document.createElement('div');
	            date.innerText = new Date().toLocaleTimeString();
	            date.className = 'client-message-timestamp';
	            container.appendChild(date);
	            container.appendChild(elem);
	            this.output.appendChild(container);
	
	            if (scrollToBottom) {
	                this.output.scrollTop = this.output.scrollHeight;
	            }
	            return this;
	        }
	    }]);
	
	    return Client;
	}();

	exports.default = Client;

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = undefined;
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _net = __webpack_require__(3);
	
	var _helpers = __webpack_require__(4);
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	/**
	 * A class representing an IRC client. Allows sending and receiving of messages
	 * to/from an IRC server.
	 */
	
	var IrcClient = function () {
	    /**
	     * Create a new IRC client.
	     * @param {host} The hostname of the server to connect to.
	     * @param {port} The port number of the server to connect to.
	     */
	
	    function IrcClient(host, port) {
	        var _this = this;
	
	        _classCallCheck(this, IrcClient);
	
	        var socket = new _net.Socket();
	        socket.setEncoding('ascii');
	        socket.connect({
	            host: host,
	            port: port
	        });
	        socket.on('data', function (data) {
	            return _this.receiveData(data);
	        });
	
	        this.socket = socket;
	        this.buffer = '';
	        this.recvEvent = (0, _helpers.event)();
	    }
	
	    /**
	     * Subscribe to messages received by the IRC server.
	     * @param {target} The target message/s to subscribe to. If a string,
	     *     matches messages of the supplied command. If a list, matches
	     *     messages of any of the supplied commands. If a predicate, matches
	     *     messages whose command satisfies the predicate.
	     * @param {handler} The callback function. Receives the message, prefix and
	     *     command.
	     * @return A callable to unsubscribe.
	     */
	
	
	    _createClass(IrcClient, [{
	        key: 'subscribe',
	        value: function subscribe(target, handler) {
	            var predicate;
	            switch (typeof target === 'undefined' ? 'undefined' : _typeof(target)) {
	                case 'string':
	                    predicate = function predicate(msg, pre, cmd) {
	                        return target === cmd;
	                    };
	                    break;
	                case 'object':
	                    predicate = function predicate(msg, pre, cmd) {
	                        return target.includes(cmd);
	                    };
	                    break;
	                default:
	                    predicate = target;
	                    break;
	            }
	            this.recvEvent.subscribe(handler, predicate);
	            return this;
	        }
	
	        /**
	         * Send a message to the IRC server.
	         * @param {message} The message to send.
	         */
	
	    }, {
	        key: 'sendMessage',
	        value: function sendMessage(message) {
	            console.log('<<< ' + message);
	            this.socket.write(message + '\r\n');
	            return this;
	        }
	
	        /**
	         * Send a command to the IRC server, by joining the array of arguments
	         * with spaces.
	         * @param {arguments} The arguments that make up the command.
	         */
	
	    }, {
	        key: 'sendCommand',
	        value: function sendCommand() {
	            var args = Array.apply(null, arguments);
	            this.sendMessage(args.join(' '));
	            return this;
	        }
	    }, {
	        key: 'receiveData',
	        value: function receiveData(data) {
	            this.buffer += data;
	            var index;
	            while (this.buffer.length > 0 && (index = this.buffer.indexOf('\n')) !== -1) {
	                var message = this.buffer.substring(0, index);
	                this.buffer = this.buffer.substring(index + 1);
	                this.receiveMessage(message);
	            }
	        }
	    }, {
	        key: 'receiveMessage',
	        value: function receiveMessage(message) {
	            console.log('>>> ' + message);
	
	            var res = (0, _helpers.split)(message);
	            var token = res[0];
	            message = res[1];
	            var prefix, command;
	            if (token[0] === ':') {
	                prefix = token;
	                res = (0, _helpers.split)(message);
	                command = res[0];
	                message = res[1];
	            } else {
	                prefix = null;
	                command = token;
	            }
	
	            this.recvEvent.notify(message, prefix, command);
	        }
	    }]);
	
	    return IrcClient;
	}();

	exports.default = IrcClient;

/***/ },
/* 3 */
/***/ function(module, exports) {

	module.exports = require("net");

/***/ },
/* 4 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.split = split;
	exports.event = event;
	exports.makeUser = makeUser;
	/**
	 * Split a string with the given separator at most n times.
	 * @param {str} The string to split.
	 * @param {sep} The separator to split on.
	 * @param {n} The maximum number of splits to make.
	 * @return An array of substrings.
	 */
	function split(str, sep, n) {
	    if (sep === undefined) {
	        sep = ' ';
	    }
	    if (n === undefined) {
	        n = 1;
	    }
	    var items = [];
	    while (n-- > 0 && str.length > 0) {
	        var index = str.indexOf(sep);
	        var item = str.substring(0, index);
	        str = str.substring(index + sep.length);
	        items.push(item);
	    }
	    if (str.length > 0) items.push(str);
	    return items;
	}
	
	/**
	 * Create a new event. The event has a subscribe method and a notify method.
	 *
	 * The subscribe method returns a callable which will unsubscribe when called,
	 * and can also have its subscribe method called to make further subscriptions.
	 * The subscribe methods take two function handles, the first is the callback
	 * which is called when the event is notified, the second is a predicate which
	 * must return true if the callback is to be invoked. The second argument is
	 * optional, if missing the callback is always called.
	 *
	 * The notify method takes any number of arguments and notifies all subscribers
	 * by calling the predicate and callback functions with the supplied arguments.
	 *
	 * @return A new event.
	 */
	function event() {
	    var subscribers = {};
	    var nextId = 0;
	    return {
	        subscribe: function subscribe(handler, predicate) {
	            var ids = [];
	            var unsubscriber = function unsubscriber() {
	                for (var ind in ids) {
	                    delete subscribers[ids[ind]];
	                }
	            };
	            unsubscriber.subscribe = function (handler, predicate) {
	                var id = nextId++;
	                ids.push(id);
	                subscribers[id] = {
	                    handler: handler,
	                    predicate: predicate || function () {
	                        return true;
	                    }
	                };
	                return this;
	            };
	            unsubscriber.subscribe(handler, predicate);
	            return unsubscriber;
	        },
	        notify: function notify() {
	            for (var id in subscribers) {
	                var subscriber = subscribers[id];
	                if (subscriber.predicate.apply(null, arguments)) {
	                    subscriber.handler.apply(null, arguments);
	                }
	            }
	        }
	    };
	}
	
	/**
	 * Parse the given user mask to create a user object.
	 * @param {mask} The user mask.
	 * @return A user object containing the mask, nick, user, domain and a HTML
	 *     span.
	 */
	function makeUser(mask) {
	    var res = split(mask, '!');
	    var nick = res[0].substring(1);
	    res = split(res[1], '@');
	    var span = document.createElement('span');
	    span.innerText = nick;
	    span.className = 'tooltip';
	    var tooltip = document.createElement('span');
	    tooltip.innerText = mask;
	    tooltip.className = 'tooltiptext';
	    span.appendChild(tooltip);
	    return {
	        mask: mask,
	        nick: nick,
	        user: res[0].substring(1),
	        domain: res[1],
	        span: span
	    };
	}

/***/ }
/******/ ]);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgNGFhYmU0ODkzYzJlNGRlZGM1YzEiLCJ3ZWJwYWNrOi8vLy4vanMvYXBwLmpzIiwid2VicGFjazovLy8uL2pzL2NvbXBvbmVudHMvQ2xpZW50LmpzIiwid2VicGFjazovLy8uL2pzL2NvbXBvbmVudHMvSXJjQ2xpZW50LmpzIiwid2VicGFjazovLy9leHRlcm5hbCBcIm5ldFwiIiwid2VicGFjazovLy8uL2pzL2hlbHBlcnMuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7OztBQ3RDQTs7Ozs7O0FBRUEsRUFBQyxZQUFXO0FBQ1IsMEJBQVcsU0FBUyxjQUFULENBQXdCLEtBQXhCLENBQVgsRUFEUTtFQUFYLEdBQUQsQzs7Ozs7Ozs7Ozs7Ozs7O0FDRkE7Ozs7QUFDQTs7Ozs7Ozs7OztLQU1xQjs7Ozs7O0FBS2pCLGNBTGlCLE1BS2pCLENBQVksU0FBWixFQUF1Qjs7OytCQUxOLFFBS007O0FBQ25CLGlCQUFRLEdBQVIsQ0FBWSxNQUFaLEVBRG1CO0FBRW5CLGFBQU0sT0FBTyxTQUFTLGFBQVQsQ0FBdUIsTUFBdkIsQ0FBUCxDQUZhO0FBR25CLGNBQUssU0FBTCxHQUFpQixRQUFqQixDQUhtQjtBQUluQixhQUFNLFNBQVMsU0FBUyxhQUFULENBQXVCLEtBQXZCLENBQVQsQ0FKYTtBQUtuQixnQkFBTyxTQUFQLEdBQW1CLGVBQW5CLENBTG1CO0FBTW5CLGdCQUFPLFFBQVAsR0FBa0IsSUFBbEIsQ0FObUI7QUFPbkIsY0FBSyxXQUFMLENBQWlCLE1BQWpCLEVBUG1CO0FBUW5CLGFBQU0sUUFBUSxTQUFTLGFBQVQs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QUksT0FBTyxJQUFJLENBQUosRUFBTyxTQUFQLENBQWlCLENBQWpCLENBQVAsQ0FGdUI7QUFHM0IsV0FBTSxNQUFNLElBQUksQ0FBSixDQUFOLEVBQWMsR0FBZCxDQUFOLENBSDJCO0FBSTNCLFNBQUksT0FBTyxTQUFTLGFBQVQsQ0FBdUIsTUFBdkIsQ0FBUCxDQUp1QjtBQUszQixVQUFLLFNBQUwsR0FBaUIsSUFBakIsQ0FMMkI7QUFNM0IsVUFBSyxTQUFMLEdBQWlCLFNBQWpCLENBTjJCO0FBTzNCLFNBQUksVUFBVSxTQUFTLGFBQVQsQ0FBdUIsTUFBdkIsQ0FBVixDQVB1QjtBQVEzQixhQUFRLFNBQVIsR0FBb0IsSUFBcEIsQ0FSMkI7QUFTM0IsYUFBUSxTQUFSLEdBQW9CLGFBQXBCLENBVDJCO0FBVTNCLFVBQUssV0FBTCxDQUFpQixPQUFqQixFQVYyQjtBQVczQixZQUFPO0FBQ0gsZUFBTSxJQUFOO0FBQ0EsZUFBTSxJQUFOO0FBQ0EsZUFBTSxJQUFJLENBQUosRUFBTyxTQUFQLENBQWlCLENBQWpCLENBQU47QUFDQSxpQkFBUSxJQUFJLENBQUosQ0FBUjtBQUNBLGVBQU0sSUFBTjtNQUxKLENBWDJCIiwiZmlsZSI6Ii4vanMvYXBwLm1pbi5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuXG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRleHBvcnRzOiB7fSxcbiBcdFx0XHRpZDogbW9kdWxlSWQsXG4gXHRcdFx0bG9hZGVkOiBmYWxzZVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogd2VicGFjay9ib290c3RyYXAgNGFhYmU0ODkzYzJlNGRlZGM1YzFcbiAqKi8iLCJpbXBvcnQgQ2xpZW50IGZyb20gJy4vY29tcG9uZW50cy9DbGllbnQuanMnO1xyXG5cclxuKGZ1bmN0aW9uKCkge1xyXG4gICAgbmV3IENsaWVudChkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYXBwJykpO1xyXG59KCkpO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vanMvYXBwLmpzXG4gKiovIiwiaW1wb3J0IElyY0NsaWVudCBmcm9tICcuL0lyY0NsaWVudC5qcyc7XHJcbmltcG9ydCB7bWFrZVVzZXIsIHNwbGl0fSBmcm9tICcuLi9oZWxwZXJzLmpzJztcclxuXHJcblxyXG4vKipcclxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgZm9ybS1iYWNrZWQgSVJDIGNsaWVudC5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENsaWVudCB7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSBhIG5ldyBjbGllbnQgYW5kIHRoZSBmb3JtIHRoYXQgcHJvdmlkZXMgaXRzIGlucHV0IGFuZCBvdXRwdXQuXHJcbiAgICAgKiBAcGFyYW0ge2NvbnRhaW5lcn0gVGhlIGNvbnRhaW5lciBlbGVtZW50IHRvIGFkZCB0aGUgZm9ybSB0by5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoY29udGFpbmVyKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ3NoaXQnKTtcclxuICAgICAgICBjb25zdCBmb3JtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZm9ybScpO1xyXG4gICAgICAgIGZvcm0uY2xhc3NOYW1lID0gJ2NsaWVudCc7XHJcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgb3V0cHV0LmNsYXNzTmFtZSA9ICdjbGllbnQtb3V0cHV0JztcclxuICAgICAgICBvdXRwdXQuZGlzYWJsZWQgPSB0cnVlO1xyXG4gICAgICAgIGZvcm0uYXBwZW5kQ2hpbGQob3V0cHV0KTtcclxuICAgICAgICBjb25zdCBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XHJcbiAgICAgICAgaW5wdXQuY2xhc3NOYW1lID0gJ2NsaWVudC1pbnB1dCc7XHJcbiAgICAgICAgaW5wdXQuYXV0b2ZvY3VzID0gdHJ1ZTtcclxuICAgICAgICBpbnB1dC5wbGFjZWhvbGRlciA9ICdKT0lOICNjaGFubmVsJztcclxuICAgICAgICBmb3JtLmFwcGVuZENoaWxkKGlucHV0KTtcclxuICAgICAgICBmb3JtLm9uc3VibWl0ID0gKCkgPT4gdGhpcy5zZW5kTWVzc2FnZSgpO1xyXG4gICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChmb3JtKTtcclxuXHJcbiAgICAgICAgY29uc3QgY2xpZW50ID0gbmV3IElyY0NsaWVudCgnY2hhdC5mcmVlbm9kZS5uZXQnLCA2NjY3KTtcclxuICAgICAgICBjbGllbnRcclxuICAgICAgICAgICAgLnN1YnNjcmliZSgnUElORycsIG1zZyA9PiB7XHJcbiAgICAgICAgICAgICAgICBjbGllbnQuc2VuZENvbW1hbmQoJ1BPTkcnLCBtc2cpO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAuc3Vic2NyaWJlKCdOT1RJQ0UnLCBtc2cgPT4ge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlcyA9IHNwbGl0KG1zZyk7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVjaXBpZW50ID0gcmVzWzBdO1xyXG4gICAgICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSByZXNbMV0uc3Vic3RyaW5nKDEpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy53cml0ZU1lc3NhZ2UobWVzc2FnZSk7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC8vIC5zdWJzY3JpYmUoWycwMDEnLCAnMDAyJywgJzAwMyddLCBtc2cgPT4geyAvLyBXZWxjb21lXHJcbiAgICAgICAgICAgIC8vICAgICB2YXIgcmVzID0gc3BsaXQobXNnKTtcclxuICAgICAgICAgICAgLy8gICAgIHZhciBtZXNzYWdlID0gcmVzWzFdLnN1YnN0cmluZygxKTtcclxuICAgICAgICAgICAgLy8gICAgIHRoaXMud3JpdGVNZXNzYWdlKG1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAvLyB9KVxyXG4gICAgICAgICAgICAvLyAuc3Vic2NyaWJlKFsnMDA0JywgJzAwNSddLCBtc2cgPT4geyAvLyBpbmZvXHJcbiAgICAgICAgICAgIC8vICAgICB2YXIgcmVzID0gc3BsaXQobXNnKTtcclxuICAgICAgICAgICAgLy8gICAgIHZhciBtZXNzYWdlID0gcmVzWzFdO1xyXG4gICAgICAgICAgICAvLyAgICAgdGhpcy53cml0ZU1lc3NhZ2UobWVzc2FnZSk7XHJcbiAgICAgICAgICAgIC8vIH0pXHJcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoWyczNTMnLCAnMzY2J10sIG1zZyA9PiB7IC8vIE5BTUVTXHJcbiAgICAgICAgICAgICAgICB2YXIgcmVzID0gc3BsaXQobXNnLCAnICcsIDIpO1xyXG4gICAgICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSByZXNbMl07XHJcbiAgICAgICAgICAgICAgICB0aGlzLndyaXRlTWVzc2FnZShtZXNzYWdlKTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLnN1YnNjcmliZShbJzQzMicsICc0MzMnLCAnNDUxJ10sIG1zZyA9PiB7IC8vIEVSUl9OSUNLTkFNRUlOVVNFXHJcbiAgICAgICAgICAgICAgICB2YXIgcmVzID0gc3BsaXQobXNnKTtcclxuICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlID0gcmVzWzFdO1xyXG4gICAgICAgICAgICAgICAgdGhpcy53cml0ZU1lc3NhZ2UobWVzc2FnZSk7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoWyc3MDQnLCAnNzA1JywgJzcwNiddLCBtc2cgPT4geyAvLyBIRUxQXHJcbiAgICAgICAgICAgICAgICB2YXIgcmVzID0gc3BsaXQobXNnLCAnICcsIDIpO1xyXG4gICAgICAgICAgICAgICAgdmFyIG1zZyA9IHJlc1syXS5zdWJzdHJpbmcoMSkudHJpbSgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG1zZyAhPT0gJycpIHRoaXMud3JpdGVNZXNzYWdlKG1zZyk7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoJ1FVSVQnLCAobXNnLCBwcmUpID0+IHtcclxuICAgICAgICAgICAgICAgIHZhciB1c2VyID0gbWFrZVVzZXIocHJlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMud3JpdGVNZXNzYWdlKHVzZXIuc3BhbiwgYCBoYXMgcXVpdDogJHttc2cuc3Vic3RyaW5nKDEpfWApO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAuc3Vic2NyaWJlKCdKT0lOJywgKG1zZywgcHJlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdXNlciA9IG1ha2VVc2VyKHByZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLndyaXRlTWVzc2FnZSh1c2VyLnNwYW4sIGAgaGFzIGpvaW5lZCAke21zZ31gKTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLnN1YnNjcmliZSgnUEFSVCcsIChtc2csIHByZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdmFyIHVzZXIgPSBtYWtlVXNlcihwcmUpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy53cml0ZU1lc3NhZ2UodXNlci5zcGFuLCBgIGhhcyBsZWZ0ICR7bXNnfWApO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAuc3Vic2NyaWJlKCdOSUNLJywgKG1zZywgcHJlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdXNlciA9IG1ha2VVc2VyKHByZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLndyaXRlTWVzc2FnZSh1c2VyLnNwYW4sIGAgaGFzIGNoYW5nZWQgbmlja25hbWVzIHRvICR7bXNnfWApO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAuc3Vic2NyaWJlKCdQUklWTVNHJywgKG1zZywgcHJlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVzID0gc3BsaXQobXNnKTtcclxuICAgICAgICAgICAgICAgIHZhciBjaGFubmVsID0gcmVzWzBdO1xyXG4gICAgICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSByZXNbMV0uc3Vic3RyaW5nKDEpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHVzZXIgPSBtYWtlVXNlcihwcmUpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy53cml0ZU1lc3NhZ2UoYCR7Y2hhbm5lbH06IGAsIHVzZXIuc3BhbiwgYDogJHttZXNzYWdlfWApO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICBjbGllbnRcclxuICAgICAgICAgICAgLnNlbmRDb21tYW5kKCdQQVNTJywgJ2N1cnRpc3Bhc3N3b3JkJylcclxuICAgICAgICAgICAgLnNlbmRDb21tYW5kKCdOSUNLJywgJ2N1cnRpczUyJylcclxuICAgICAgICAgICAgLnNlbmRDb21tYW5kKCdVU0VSJywgJ2N1cnRpczUyJywgJzAnLCAnKicsICdjdXJ0aXMnKTtcclxuXHJcbiAgICAgICAgdGhpcy5mb3JtID0gZm9ybTtcclxuICAgICAgICB0aGlzLmlucHV0ID0gaW5wdXQ7XHJcbiAgICAgICAgdGhpcy5vdXRwdXQgPSBvdXRwdXQ7XHJcbiAgICAgICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZW5kIGEgbWVzc2FnZSB0byB0aGUgSVJDIHNlcnZlci5cclxuICAgICAqIEBwYXJhbSB7YXJndW1lbnRzfSBUaGUgY29tcG9uZW50cyBvZiB0aGUgbWVzc2FnZSB0byBzZW5kLlxyXG4gICAgICovXHJcbiAgICBzZW5kTWVzc2FnZSgpIHtcclxuICAgICAgICB2YXIgbWVzc2FnZSA9IHRoaXMuaW5wdXQudmFsdWU7XHJcbiAgICAgICAgdGhpcy5pbnB1dC52YWx1ZSA9ICcnO1xyXG5cclxuICAgICAgICB0aGlzLmNsaWVudC5zZW5kTWVzc2FnZShtZXNzYWdlKTtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXcml0ZSBhIG1lc3NhZ2UgdG8gdGhlIGZvcm0gb3V0cHV0LiBBZGRzIGFsbCBhcmd1bWVudHMgdG8gYSBjb250YWluZXJcclxuICAgICAqIGVsZW1lbnQgd2hpY2ggcmVwcmVzZW50cyBhIHNpbmdsZSBtZXNzYWdlLlxyXG4gICAgICogQHBhcmFtIHthcmd1bWVudHN9IFRoZSBjb21wb25lbnRzIG9mIHRoZSBtZXNzYWdlLlxyXG4gICAgICovXHJcbiAgICB3cml0ZU1lc3NhZ2UoKSB7XHJcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiYgYXJndW1lbnRzWzBdID09PSAnJykge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnZW1wdHknKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGVsZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgICAgICBmb3IgKHZhciBpbmQgaW4gYXJndW1lbnRzKSB7XHJcbiAgICAgICAgICAgIHZhciBhcmd1bWVudCA9IGFyZ3VtZW50c1tpbmRdO1xyXG4gICAgICAgICAgICBlbGVtLmFwcGVuZENoaWxkKGFyZ3VtZW50IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgPyBhcmd1bWVudCA6IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGFyZ3VtZW50KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLndyaXRlRWxlbWVudChlbGVtKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFdyaXRlIGEgSFRNTCBlbGVtZW50IHRvIHRoZSBmb3JtIG91dHB1dC5cclxuICAgICAqIEBwYXJhbSB7ZWxlbX0gQSBIVE1MIGVsZW1lbnQuXHJcbiAgICAgKi9cclxuICAgIHdyaXRlRWxlbWVudChlbGVtKSB7XHJcbiAgICAgICAgdmFyIHNjcm9sbFRvQm90dG9tID0gdGhpcy5vdXRwdXQuc2Nyb2xsVG9wICsgdGhpcy5vdXRwdXQuY2xpZW50SGVpZ2h0ICsgMSA+PSB0aGlzLm91dHB1dC5zY3JvbGxIZWlnaHQ7XHJcblxyXG4gICAgICAgIHZhciBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgICAgICBjb250YWluZXIuY2xhc3NOYW1lID0gJ2NsaWVudC1tZXNzYWdlJztcclxuICAgICAgICB2YXIgZGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICAgIGRhdGUuaW5uZXJUZXh0ID0gbmV3IERhdGUoKS50b0xvY2FsZVRpbWVTdHJpbmcoKTtcclxuICAgICAgICBkYXRlLmNsYXNzTmFtZSA9ICdjbGllbnQtbWVzc2FnZS10aW1lc3RhbXAnO1xyXG4gICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChkYXRlKTtcclxuICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoZWxlbSk7XHJcbiAgICAgICAgdGhpcy5vdXRwdXQuYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcclxuXHJcbiAgICAgICAgaWYgKHNjcm9sbFRvQm90dG9tKSB7IHRoaXMub3V0cHV0LnNjcm9sbFRvcCA9IHRoaXMub3V0cHV0LnNjcm9sbEhlaWdodDsgfVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG59XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9qcy9jb21wb25lbnRzL0NsaWVudC5qc1xuICoqLyIsImltcG9ydCB7U29ja2V0fSBmcm9tICduZXQnO1xyXG5pbXBvcnQge2V2ZW50LCBzcGxpdH0gZnJvbSAnLi4vaGVscGVycy5qcyc7XHJcblxyXG5cclxuLyoqXHJcbiAqIEEgY2xhc3MgcmVwcmVzZW50aW5nIGFuIElSQyBjbGllbnQuIEFsbG93cyBzZW5kaW5nIGFuZCByZWNlaXZpbmcgb2YgbWVzc2FnZXNcclxuICogdG8vZnJvbSBhbiBJUkMgc2VydmVyLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSXJjQ2xpZW50IHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIGEgbmV3IElSQyBjbGllbnQuXHJcbiAgICAgKiBAcGFyYW0ge2hvc3R9IFRoZSBob3N0bmFtZSBvZiB0aGUgc2VydmVyIHRvIGNvbm5lY3QgdG8uXHJcbiAgICAgKiBAcGFyYW0ge3BvcnR9IFRoZSBwb3J0IG51bWJlciBvZiB0aGUgc2VydmVyIHRvIGNvbm5lY3QgdG8uXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGhvc3QsIHBvcnQpIHtcclxuICAgICAgICBjb25zdCBzb2NrZXQgPSBuZXcgU29ja2V0KCk7XHJcbiAgICAgICAgc29ja2V0LnNldEVuY29kaW5nKCdhc2NpaScpO1xyXG4gICAgICAgIHNvY2tldC5jb25uZWN0KHtcclxuICAgICAgICAgICAgaG9zdDogaG9zdCxcclxuICAgICAgICAgICAgcG9ydDogcG9ydFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHNvY2tldC5vbignZGF0YScsIGRhdGEgPT4gdGhpcy5yZWNlaXZlRGF0YShkYXRhKSk7XHJcblxyXG4gICAgICAgIHRoaXMuc29ja2V0ID0gc29ja2V0O1xyXG4gICAgICAgIHRoaXMuYnVmZmVyID0gJyc7XHJcbiAgICAgICAgdGhpcy5yZWN2RXZlbnQgPSBldmVudCgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3Vic2NyaWJlIHRvIG1lc3NhZ2VzIHJlY2VpdmVkIGJ5IHRoZSBJUkMgc2VydmVyLlxyXG4gICAgICogQHBhcmFtIHt0YXJnZXR9IFRoZSB0YXJnZXQgbWVzc2FnZS9zIHRvIHN1YnNjcmliZSB0by4gSWYgYSBzdHJpbmcsXHJcbiAgICAgKiAgICAgbWF0Y2hlcyBtZXNzYWdlcyBvZiB0aGUgc3VwcGxpZWQgY29tbWFuZC4gSWYgYSBsaXN0LCBtYXRjaGVzXHJcbiAgICAgKiAgICAgbWVzc2FnZXMgb2YgYW55IG9mIHRoZSBzdXBwbGllZCBjb21tYW5kcy4gSWYgYSBwcmVkaWNhdGUsIG1hdGNoZXNcclxuICAgICAqICAgICBtZXNzYWdlcyB3aG9zZSBjb21tYW5kIHNhdGlzZmllcyB0aGUgcHJlZGljYXRlLlxyXG4gICAgICogQHBhcmFtIHtoYW5kbGVyfSBUaGUgY2FsbGJhY2sgZnVuY3Rpb24uIFJlY2VpdmVzIHRoZSBtZXNzYWdlLCBwcmVmaXggYW5kXHJcbiAgICAgKiAgICAgY29tbWFuZC5cclxuICAgICAqIEByZXR1cm4gQSBjYWxsYWJsZSB0byB1bnN1YnNjcmliZS5cclxuICAgICAqL1xyXG4gICAgc3Vic2NyaWJlKHRhcmdldCwgaGFuZGxlcikge1xyXG4gICAgICAgIHZhciBwcmVkaWNhdGU7XHJcbiAgICAgICAgc3dpdGNoICh0eXBlb2YodGFyZ2V0KSkge1xyXG4gICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxyXG4gICAgICAgICAgICAgICAgcHJlZGljYXRlID0gKG1zZywgcHJlLCBjbWQpID0+IHRhcmdldCA9PT0gY21kO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XHJcbiAgICAgICAgICAgICAgICBwcmVkaWNhdGUgPSAobXNnLCBwcmUsIGNtZCkgPT4gdGFyZ2V0LmluY2x1ZGVzKGNtZCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHByZWRpY2F0ZSA9IHRhcmdldDtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnJlY3ZFdmVudC5zdWJzY3JpYmUoaGFuZGxlciwgcHJlZGljYXRlKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNlbmQgYSBtZXNzYWdlIHRvIHRoZSBJUkMgc2VydmVyLlxyXG4gICAgICogQHBhcmFtIHttZXNzYWdlfSBUaGUgbWVzc2FnZSB0byBzZW5kLlxyXG4gICAgICovXHJcbiAgICBzZW5kTWVzc2FnZShtZXNzYWdlKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coYDw8PCAke21lc3NhZ2V9YCk7XHJcbiAgICAgICAgdGhpcy5zb2NrZXQud3JpdGUobWVzc2FnZSArICdcXHJcXG4nKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNlbmQgYSBjb21tYW5kIHRvIHRoZSBJUkMgc2VydmVyLCBieSBqb2luaW5nIHRoZSBhcnJheSBvZiBhcmd1bWVudHNcclxuICAgICAqIHdpdGggc3BhY2VzLlxyXG4gICAgICogQHBhcmFtIHthcmd1bWVudHN9IFRoZSBhcmd1bWVudHMgdGhhdCBtYWtlIHVwIHRoZSBjb21tYW5kLlxyXG4gICAgICovXHJcbiAgICBzZW5kQ29tbWFuZCgpIHtcclxuICAgICAgICB2YXIgYXJncyA9IEFycmF5LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgdGhpcy5zZW5kTWVzc2FnZShhcmdzLmpvaW4oJyAnKSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgcmVjZWl2ZURhdGEoZGF0YSkge1xyXG4gICAgICAgIHRoaXMuYnVmZmVyICs9IGRhdGE7XHJcbiAgICAgICAgdmFyIGluZGV4O1xyXG4gICAgICAgIHdoaWxlICh0aGlzLmJ1ZmZlci5sZW5ndGggPiAwICYmIChpbmRleCA9IHRoaXMuYnVmZmVyLmluZGV4T2YoJ1xcbicpKSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSB0aGlzLmJ1ZmZlci5zdWJzdHJpbmcoMCwgaW5kZXgpO1xyXG4gICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IHRoaXMuYnVmZmVyLnN1YnN0cmluZyhpbmRleCsxKTtcclxuICAgICAgICAgICAgdGhpcy5yZWNlaXZlTWVzc2FnZShtZXNzYWdlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmVjZWl2ZU1lc3NhZ2UobWVzc2FnZSkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGA+Pj4gJHttZXNzYWdlfWApO1xyXG5cclxuICAgICAgICB2YXIgcmVzID0gc3BsaXQobWVzc2FnZSk7XHJcbiAgICAgICAgdmFyIHRva2VuID0gcmVzWzBdO1xyXG4gICAgICAgIG1lc3NhZ2UgPSByZXNbMV07XHJcbiAgICAgICAgdmFyIHByZWZpeCwgY29tbWFuZDtcclxuICAgICAgICBpZiAodG9rZW5bMF0gPT09ICc6Jykge1xyXG4gICAgICAgICAgICBwcmVmaXggPSB0b2tlbjtcclxuICAgICAgICAgICAgcmVzID0gc3BsaXQobWVzc2FnZSk7XHJcbiAgICAgICAgICAgIGNvbW1hbmQgPSByZXNbMF07XHJcbiAgICAgICAgICAgIG1lc3NhZ2UgPSByZXNbMV07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcHJlZml4ID0gbnVsbDtcclxuICAgICAgICAgICAgY29tbWFuZCA9IHRva2VuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5yZWN2RXZlbnQubm90aWZ5KG1lc3NhZ2UsIHByZWZpeCwgY29tbWFuZCk7XHJcbiAgICB9XHJcbn1cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2pzL2NvbXBvbmVudHMvSXJjQ2xpZW50LmpzXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwibmV0XCIpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogZXh0ZXJuYWwgXCJuZXRcIlxuICoqIG1vZHVsZSBpZCA9IDNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxyXG4gKiBTcGxpdCBhIHN0cmluZyB3aXRoIHRoZSBnaXZlbiBzZXBhcmF0b3IgYXQgbW9zdCBuIHRpbWVzLlxyXG4gKiBAcGFyYW0ge3N0cn0gVGhlIHN0cmluZyB0byBzcGxpdC5cclxuICogQHBhcmFtIHtzZXB9IFRoZSBzZXBhcmF0b3IgdG8gc3BsaXQgb24uXHJcbiAqIEBwYXJhbSB7bn0gVGhlIG1heGltdW0gbnVtYmVyIG9mIHNwbGl0cyB0byBtYWtlLlxyXG4gKiBAcmV0dXJuIEFuIGFycmF5IG9mIHN1YnN0cmluZ3MuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gc3BsaXQoc3RyLCBzZXAsIG4pIHtcclxuICAgIGlmIChzZXAgPT09IHVuZGVmaW5lZCkgeyBzZXAgPSAnICc7IH1cclxuICAgIGlmIChuID09PSB1bmRlZmluZWQpIHsgbiA9IDE7IH1cclxuICAgIHZhciBpdGVtcyA9IFtdO1xyXG4gICAgd2hpbGUgKG4tLSA+IDAgJiYgc3RyLmxlbmd0aCA+IDApIHtcclxuICAgICAgICB2YXIgaW5kZXggPSBzdHIuaW5kZXhPZihzZXApO1xyXG4gICAgICAgIHZhciBpdGVtID0gc3RyLnN1YnN0cmluZygwLCBpbmRleCk7XHJcbiAgICAgICAgc3RyID0gc3RyLnN1YnN0cmluZyhpbmRleCtzZXAubGVuZ3RoKTtcclxuICAgICAgICBpdGVtcy5wdXNoKGl0ZW0pO1xyXG4gICAgfVxyXG4gICAgaWYgKHN0ci5sZW5ndGggPiAwKSBpdGVtcy5wdXNoKHN0cik7XHJcbiAgICByZXR1cm4gaXRlbXM7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDcmVhdGUgYSBuZXcgZXZlbnQuIFRoZSBldmVudCBoYXMgYSBzdWJzY3JpYmUgbWV0aG9kIGFuZCBhIG5vdGlmeSBtZXRob2QuXHJcbiAqXHJcbiAqIFRoZSBzdWJzY3JpYmUgbWV0aG9kIHJldHVybnMgYSBjYWxsYWJsZSB3aGljaCB3aWxsIHVuc3Vic2NyaWJlIHdoZW4gY2FsbGVkLFxyXG4gKiBhbmQgY2FuIGFsc28gaGF2ZSBpdHMgc3Vic2NyaWJlIG1ldGhvZCBjYWxsZWQgdG8gbWFrZSBmdXJ0aGVyIHN1YnNjcmlwdGlvbnMuXHJcbiAqIFRoZSBzdWJzY3JpYmUgbWV0aG9kcyB0YWtlIHR3byBmdW5jdGlvbiBoYW5kbGVzLCB0aGUgZmlyc3QgaXMgdGhlIGNhbGxiYWNrXHJcbiAqIHdoaWNoIGlzIGNhbGxlZCB3aGVuIHRoZSBldmVudCBpcyBub3RpZmllZCwgdGhlIHNlY29uZCBpcyBhIHByZWRpY2F0ZSB3aGljaFxyXG4gKiBtdXN0IHJldHVybiB0cnVlIGlmIHRoZSBjYWxsYmFjayBpcyB0byBiZSBpbnZva2VkLiBUaGUgc2Vjb25kIGFyZ3VtZW50IGlzXHJcbiAqIG9wdGlvbmFsLCBpZiBtaXNzaW5nIHRoZSBjYWxsYmFjayBpcyBhbHdheXMgY2FsbGVkLlxyXG4gKlxyXG4gKiBUaGUgbm90aWZ5IG1ldGhvZCB0YWtlcyBhbnkgbnVtYmVyIG9mIGFyZ3VtZW50cyBhbmQgbm90aWZpZXMgYWxsIHN1YnNjcmliZXJzXHJcbiAqIGJ5IGNhbGxpbmcgdGhlIHByZWRpY2F0ZSBhbmQgY2FsbGJhY2sgZnVuY3Rpb25zIHdpdGggdGhlIHN1cHBsaWVkIGFyZ3VtZW50cy5cclxuICpcclxuICogQHJldHVybiBBIG5ldyBldmVudC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBldmVudCgpIHtcclxuICAgIHZhciBzdWJzY3JpYmVycyA9IHt9O1xyXG4gICAgdmFyIG5leHRJZCA9IDA7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHN1YnNjcmliZTogZnVuY3Rpb24gKGhhbmRsZXIsIHByZWRpY2F0ZSkge1xyXG4gICAgICAgICAgICB2YXIgaWRzID0gW107XHJcbiAgICAgICAgICAgIHZhciB1bnN1YnNjcmliZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpbmQgaW4gaWRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHN1YnNjcmliZXJzW2lkc1tpbmRdXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdW5zdWJzY3JpYmVyLnN1YnNjcmliZSA9IGZ1bmN0aW9uIChoYW5kbGVyLCBwcmVkaWNhdGUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBpZCA9IG5leHRJZCsrO1xyXG4gICAgICAgICAgICAgICAgaWRzLnB1c2goaWQpO1xyXG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlcnNbaWRdID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZXI6IGhhbmRsZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgcHJlZGljYXRlOiBwcmVkaWNhdGUgfHwgKCgpID0+IHRydWUpXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHVuc3Vic2NyaWJlci5zdWJzY3JpYmUoaGFuZGxlciwgcHJlZGljYXRlKTtcclxuICAgICAgICAgICAgcmV0dXJuIHVuc3Vic2NyaWJlcjtcclxuICAgICAgICB9LFxyXG4gICAgICAgIG5vdGlmeTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpZCBpbiBzdWJzY3JpYmVycykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHN1YnNjcmliZXIgPSBzdWJzY3JpYmVyc1tpZF07XHJcbiAgICAgICAgICAgICAgICBpZiAoc3Vic2NyaWJlci5wcmVkaWNhdGUuYXBwbHkobnVsbCwgYXJndW1lbnRzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZXIuaGFuZGxlci5hcHBseShudWxsLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFBhcnNlIHRoZSBnaXZlbiB1c2VyIG1hc2sgdG8gY3JlYXRlIGEgdXNlciBvYmplY3QuXHJcbiAqIEBwYXJhbSB7bWFza30gVGhlIHVzZXIgbWFzay5cclxuICogQHJldHVybiBBIHVzZXIgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG1hc2ssIG5pY2ssIHVzZXIsIGRvbWFpbiBhbmQgYSBIVE1MXHJcbiAqICAgICBzcGFuLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIG1ha2VVc2VyKG1hc2spIHtcclxuICAgIHZhciByZXMgPSBzcGxpdChtYXNrLCAnIScpO1xyXG4gICAgdmFyIG5pY2sgPSByZXNbMF0uc3Vic3RyaW5nKDEpO1xyXG4gICAgcmVzID0gc3BsaXQocmVzWzFdLCAnQCcpO1xyXG4gICAgdmFyIHNwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XHJcbiAgICBzcGFuLmlubmVyVGV4dCA9IG5pY2s7XHJcbiAgICBzcGFuLmNsYXNzTmFtZSA9ICd0b29sdGlwJztcclxuICAgIHZhciB0b29sdGlwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xyXG4gICAgdG9vbHRpcC5pbm5lclRleHQgPSBtYXNrO1xyXG4gICAgdG9vbHRpcC5jbGFzc05hbWUgPSAndG9vbHRpcHRleHQnO1xyXG4gICAgc3Bhbi5hcHBlbmRDaGlsZCh0b29sdGlwKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgbWFzazogbWFzayxcclxuICAgICAgICBuaWNrOiBuaWNrLFxyXG4gICAgICAgIHVzZXI6IHJlc1swXS5zdWJzdHJpbmcoMSksXHJcbiAgICAgICAgZG9tYWluOiByZXNbMV0sXHJcbiAgICAgICAgc3Bhbjogc3BhblxyXG4gICAgfTtcclxufVxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vanMvaGVscGVycy5qc1xuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=