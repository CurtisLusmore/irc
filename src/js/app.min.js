/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var _Client = __webpack_require__(1);
	
	var _Client2 = _interopRequireDefault(_Client);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	(function () {
	    new _Client2.default(document.getElementById('app'));
	})();

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _IrcClient = __webpack_require__(2);
	
	var _IrcClient2 = _interopRequireDefault(_IrcClient);
	
	var _helpers = __webpack_require__(4);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	/**
	 * Class representing a form-backed IRC client.
	 */
	
	var Client = function () {
	    /**
	     * Create a new client and the form that provides its input and output.
	     * @param {container} The container element to add the form to.
	     */
	
	    function Client(container) {
	        var _this = this;
	
	        _classCallCheck(this, Client);
	
	        var form = document.createElement('form');
	        form.className = 'client';
	        var output = document.createElement('div');
	        output.className = 'client-output';
	        output.disabled = true;
	        form.appendChild(output);
	        var input = document.createElement('input');
	        input.className = 'client-input';
	        input.autofocus = true;
	        input.placeholder = 'JOIN #channel';
	        form.appendChild(input);
	        form.onsubmit = function () {
	            return _this.sendMessage();
	        };
	        container.appendChild(form);
	
	        var client = new _IrcClient2.default('chat.freenode.net', 6667);
	        client.subscribe('PING', function (msg) {
	            client.sendCommand('PONG', msg);
	        }).subscribe('NOTICE', function (msg) {
	            var res = (0, _helpers.split)(msg);
	            var recipient = res[0];
	            var message = res[1].substring(1);
	            _this.writeMessage(message);
	        })
	        // .subscribe(['001', '002', '003'], msg => { // Welcome
	        //     var res = split(msg);
	        //     var message = res[1].substring(1);
	        //     this.writeMessage(message);
	        // })
	        // .subscribe(['004', '005'], msg => { // info
	        //     var res = split(msg);
	        //     var message = res[1];
	        //     this.writeMessage(message);
	        // })
	        .subscribe(['353', '366'], function (msg) {
	            // NAMES
	            var res = (0, _helpers.split)(msg, ' ', 2);
	            var message = res[2];
	            _this.writeMessage(message);
	        }).subscribe(['432', '433', '451'], function (msg) {
	            // ERR_NICKNAMEINUSE
	            var res = (0, _helpers.split)(msg);
	            var message = res[1];
	            _this.writeMessage(message);
	        }).subscribe(['704', '705', '706'], function (msg) {
	            // HELP
	            var res = (0, _helpers.split)(msg, ' ', 2);
	            var msg = res[2].substring(1).trim();
	            if (msg !== '') _this.writeMessage(msg);
	        }).subscribe('QUIT', function (msg, pre) {
	            var user = (0, _helpers.makeUser)(pre);
	            _this.writeMessage(user.span, " has quit: " + msg.substring(1));
	        }).subscribe('JOIN', function (msg, pre) {
	            var user = (0, _helpers.makeUser)(pre);
	            _this.writeMessage(user.span, " has joined " + msg);
	        }).subscribe('PART', function (msg, pre) {
	            var user = (0, _helpers.makeUser)(pre);
	            _this.writeMessage(user.span, " has left " + msg);
	        }).subscribe('NICK', function (msg, pre) {
	            var user = (0, _helpers.makeUser)(pre);
	            _this.writeMessage(user.span, " has changed nicknames to " + msg);
	        }).subscribe('PRIVMSG', function (msg, pre) {
	            var res = (0, _helpers.split)(msg);
	            var channel = res[0];
	            var message = res[1].substring(1);
	            var user = (0, _helpers.makeUser)(pre);
	            _this.writeMessage(channel + ": ", user.span, ": " + message);
	        });
	        client.sendCommand('PASS', 'curtispassword').sendCommand('NICK', 'curtis52').sendCommand('USER', 'curtis52', '0', '*', 'curtis');
	
	        this.form = form;
	        this.input = input;
	        this.output = output;
	        this.client = client;
	    }
	
	    /**
	     * Send a message to the IRC server.
	     * @param {arguments} The components of the message to send.
	     */
	
	
	    _createClass(Client, [{
	        key: "sendMessage",
	        value: function sendMessage() {
	            var message = this.input.value;
	            this.input.value = '';
	
	            this.client.sendMessage(message);
	            return false;
	        }
	
	        /**
	         * Write a message to the form output. Adds all arguments to a container
	         * element which represents a single message.
	         * @param {arguments} The components of the message.
	         */
	
	    }, {
	        key: "writeMessage",
	        value: function writeMessage() {
	            if (arguments.length === 1 && arguments[0] === '') {
	                console.log('empty');
	            }
	            var elem = document.createElement('div');
	            for (var ind in arguments) {
	                var argument = arguments[ind];
	                elem.appendChild(argument instanceof HTMLElement ? argument : document.createTextNode(argument));
	            }
	            return this.writeElement(elem);
	        }
	
	        /**
	         * Write a HTML element to the form output.
	         * @param {elem} A HTML element.
	         */
	
	    }, {
	        key: "writeElement",
	        value: function writeElement(elem) {
	            var scrollToBottom = this.output.scrollTop + this.output.clientHeight + 1 >= this.output.scrollHeight;
	
	            var container = document.createElement('div');
	            container.className = 'client-message';
	            var date = document.createElement('div');
	            date.innerText = new Date().toLocaleTimeString();
	            date.className = 'client-message-timestamp';
	            container.appendChild(date);
	            container.appendChild(elem);
	            this.output.appendChild(container);
	
	            if (scrollToBottom) {
	                this.output.scrollTop = this.output.scrollHeight;
	            }
	            return this;
	        }
	    }]);
	
	    return Client;
	}();
	
	(function () {
	    new Client(document.getElementById('app'));
	})();

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _net = __webpack_require__(3);
	
	var _net2 = _interopRequireDefault(_net);
	
	var _helpers = __webpack_require__(4);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	/**
	 * A class representing an IRC client. Allows sending and receiving of messages
	 * to/from an IRC server.
	 */
	
	var IrcClient = function () {
	    /**
	     * Create a new IRC client.
	     * @param {host} The hostname of the server to connect to.
	     * @param {port} The port number of the server to connect to.
	     */
	
	    function IrcClient(host, port) {
	        var _this = this;
	
	        _classCallCheck(this, IrcClient);
	
	        var socket = new _net2.default();
	        socket.setEncoding('ascii');
	        socket.connect({
	            host: host,
	            port: port
	        });
	        socket.on('data', function (data) {
	            return _this.receiveData(data);
	        });
	
	        this.socket = socket;
	        this.buffer = '';
	        this.recvEvent = (0, _helpers.event)();
	    }
	
	    /**
	     * Subscribe to messages received by the IRC server.
	     * @param {target} The target message/s to subscribe to. If a string,
	     *     matches messages of the supplied command. If a list, matches
	     *     messages of any of the supplied commands. If a predicate, matches
	     *     messages whose command satisfies the predicate.
	     * @param {handler} The callback function. Receives the message, prefix and
	     *     command.
	     * @return A callable to unsubscribe.
	     */
	
	
	    _createClass(IrcClient, [{
	        key: 'subscribe',
	        value: function subscribe(target, handler) {
	            var predicate;
	            switch (typeof target === 'undefined' ? 'undefined' : _typeof(target)) {
	                case 'string':
	                    predicate = function predicate(msg, pre, cmd) {
	                        return target === cmd;
	                    };
	                    break;
	                case 'object':
	                    predicate = function predicate(msg, pre, cmd) {
	                        return target.includes(cmd);
	                    };
	                    break;
	                default:
	                    predicate = target;
	                    break;
	            }
	            this.recvEvent.subscribe(handler, predicate);
	            return this;
	        }
	
	        /**
	         * Send a message to the IRC server.
	         * @param {message} The message to send.
	         */
	
	    }, {
	        key: 'sendMessage',
	        value: function sendMessage(message) {
	            console.log('<<< ' + message);
	            this.socket.write(message + '\r\n');
	            return this;
	        }
	
	        /**
	         * Send a command to the IRC server, by joining the array of arguments
	         * with spaces.
	         * @param {arguments} The arguments that make up the command.
	         */
	
	    }, {
	        key: 'sendCommand',
	        value: function sendCommand() {
	            var args = Array.apply(null, arguments);
	            this.sendMessage(args.join(' '));
	            return this;
	        }
	    }, {
	        key: 'receiveData',
	        value: function receiveData(data) {
	            this.buffer += data;
	            var index;
	            while (this.buffer.length > 0 && (index = this.buffer.indexOf('\n')) !== -1) {
	                var message = this.buffer.substring(0, index);
	                this.buffer = this.buffer.substring(index + 1);
	                this.receiveMessage(message);
	            }
	        }
	    }, {
	        key: 'receiveMessage',
	        value: function receiveMessage(message) {
	            console.log('>>> ' + message);
	
	            var res = (0, _helpers.split)(message);
	            var token = res[0];
	            message = res[1];
	            var prefix, command;
	            if (token[0] === ':') {
	                prefix = token;
	                res = (0, _helpers.split)(message);
	                command = res[0];
	                message = res[1];
	            } else {
	                prefix = null;
	                command = token;
	            }
	
	            this.recvEvent.notify(message, prefix, command);
	        }
	    }]);
	
	    return IrcClient;
	}();

/***/ },
/* 3 */
/***/ function(module, exports) {

	module.exports = require("net");

/***/ },
/* 4 */
/***/ function(module, exports) {

	'use strict';
	
	/**
	 * Split a string with the given separator at most n times.
	 * @param {str} The string to split.
	 * @param {sep} The separator to split on.
	 * @param {n} The maximum number of splits to make.
	 * @return An array of substrings.
	 */
	function split(str, sep, n) {
	    if (sep === undefined) {
	        sep = ' ';
	    }
	    if (n === undefined) {
	        n = 1;
	    }
	    var items = [];
	    while (n-- > 0 && str.length > 0) {
	        var index = str.indexOf(sep);
	        var item = str.substring(0, index);
	        str = str.substring(index + sep.length);
	        items.push(item);
	    }
	    if (str.length > 0) items.push(str);
	    return items;
	}
	
	/**
	 * Create a new event. The event has a subscribe method and a notify method.
	 *
	 * The subscribe method returns a callable which will unsubscribe when called,
	 * and can also have its subscribe method called to make further subscriptions.
	 * The subscribe methods take two function handles, the first is the callback
	 * which is called when the event is notified, the second is a predicate which
	 * must return true if the callback is to be invoked. The second argument is
	 * optional, if missing the callback is always called.
	 *
	 * The notify method takes any number of arguments and notifies all subscribers
	 * by calling the predicate and callback functions with the supplied arguments.
	 *
	 * @return A new event.
	 */
	function event() {
	    var subscribers = {};
	    var nextId = 0;
	    return {
	        subscribe: function subscribe(handler, predicate) {
	            var ids = [];
	            var unsubscriber = function unsubscriber() {
	                for (var ind in ids) {
	                    delete subscribers[ids[ind]];
	                }
	            };
	            unsubscriber.subscribe = function (handler, predicate) {
	                var id = nextId++;
	                ids.push(id);
	                subscribers[id] = {
	                    handler: handler,
	                    predicate: predicate || function () {
	                        return true;
	                    }
	                };
	                return this;
	            };
	            unsubscriber.subscribe(handler, predicate);
	            return unsubscriber;
	        },
	        notify: function notify() {
	            for (var id in subscribers) {
	                var subscriber = subscribers[id];
	                if (subscriber.predicate.apply(null, arguments)) {
	                    subscriber.handler.apply(null, arguments);
	                }
	            }
	        }
	    };
	}
	
	/**
	 * Parse the given user mask to create a user object.
	 * @param {mask} The user mask.
	 * @return A user object containing the mask, nick, user, domain and a HTML
	 *     span.
	 */
	function makeUser(mask) {
	    var res = split(mask, '!');
	    var nick = res[0].substring(1);
	    res = split(res[1], '@');
	    var span = document.createElement('span');
	    span.innerText = nick;
	    span.className = 'tooltip';
	    var tooltip = document.createElement('span');
	    tooltip.innerText = mask;
	    tooltip.className = 'tooltiptext';
	    span.appendChild(tooltip);
	    return {
	        mask: mask,
	        nick: nick,
	        user: res[0].substring(1),
	        domain: res[1],
	        span: span
	    };
	}

/***/ }
/******/ ]);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgNjE4MTZiYjY5NmRjNGIwZWRjOWQiLCJ3ZWJwYWNrOi8vLy4vanMvYXBwLmpzIiwid2VicGFjazovLy8uL2pzL2NvbXBvbmVudHMvQ2xpZW50LmpzIiwid2VicGFjazovLy8uL2pzL2NvbXBvbmVudHMvSXJjQ2xpZW50LmpzIiwid2VicGFjazovLy9leHRlcm5hbCBcIm5ldFwiIiwid2VicGFjazovLy8uL2pzL2hlbHBlcnMuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7OztBQ3RDQTs7Ozs7O0FBRUEsRUFBQyxZQUFXO0FBQ1IsMEJBQVcsU0FBUyxjQUFULENBQXdCLEtBQXhCLENBQVgsRUFEUTtFQUFYLEdBQUQsQzs7Ozs7Ozs7OztBQ0ZBOzs7O0FBQ0E7Ozs7Ozs7Ozs7S0FNTTs7Ozs7O0FBS0YsY0FMRSxNQUtGLENBQVksU0FBWixFQUF1Qjs7OytCQUxyQixRQUtxQjs7QUFDbkIsYUFBSSxPQUFPLFNBQVMsYUFBVCxDQUF1QixNQUF2QixDQUFQLENBRGU7QUFFbkIsY0FBSyxTQUFMLEdBQWlCLFFBQWpCLENBRm1CO0FBR25CLGFBQUksU0FBUyxTQUFTLGFBQVQsQ0FBdUIsS0FBdkIsQ0FBVCxDQUhlO0FBSW5CLGdCQUFPLFNBQVAsR0FBbUIsZUFBbkIsQ0FKbUI7QUFLbkIsZ0JBQU8sUUFBUCxHQUFrQixJQUFsQixDQUxtQjtBQU1uQixjQUFLLFdBQUwsQ0FBaUIsTUFBakIsRUFObUI7QUFPbkIsYUFBSSxRQUFRLFNBQVMsYUFBVCxDQUF1QixPQUF2QixDQUFSLENBUGU7QUFRbkIsZUFBTSxTQUFOLEdB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QixTQUFJLE9BQU8sSUFBSSxDQUFKLEVBQU8sU0FBUCxDQUFpQixDQUFqQixDQUFQLENBRmdCO0FBR3BCLFdBQU0sTUFBTSxJQUFJLENBQUosQ0FBTixFQUFjLEdBQWQsQ0FBTixDQUhvQjtBQUlwQixTQUFJLE9BQU8sU0FBUyxhQUFULENBQXVCLE1BQXZCLENBQVAsQ0FKZ0I7QUFLcEIsVUFBSyxTQUFMLEdBQWlCLElBQWpCLENBTG9CO0FBTXBCLFVBQUssU0FBTCxHQUFpQixTQUFqQixDQU5vQjtBQU9wQixTQUFJLFVBQVUsU0FBUyxhQUFULENBQXVCLE1BQXZCLENBQVYsQ0FQZ0I7QUFRcEIsYUFBUSxTQUFSLEdBQW9CLElBQXBCLENBUm9CO0FBU3BCLGFBQVEsU0FBUixHQUFvQixhQUFwQixDQVRvQjtBQVVwQixVQUFLLFdBQUwsQ0FBaUIsT0FBakIsRUFWb0I7QUFXcEIsWUFBTztBQUNILGVBQU0sSUFBTjtBQUNBLGVBQU0sSUFBTjtBQUNBLGVBQU0sSUFBSSxDQUFKLEVBQU8sU0FBUCxDQUFpQixDQUFqQixDQUFOO0FBQ0EsaUJBQVEsSUFBSSxDQUFKLENBQVI7QUFDQSxlQUFNLElBQU47TUFMSixDQVhvQiIsImZpbGUiOiIuL2pzL2FwcC5taW4uanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSlcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcblxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0ZXhwb3J0czoge30sXG4gXHRcdFx0aWQ6IG1vZHVsZUlkLFxuIFx0XHRcdGxvYWRlZDogZmFsc2VcbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubG9hZGVkID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIHdlYnBhY2svYm9vdHN0cmFwIDYxODE2YmI2OTZkYzRiMGVkYzlkXG4gKiovIiwiaW1wb3J0IENsaWVudCBmcm9tIFwiLi9jb21wb25lbnRzL0NsaWVudC5qc1wiO1xyXG5cclxuKGZ1bmN0aW9uKCkge1xyXG4gICAgbmV3IENsaWVudChkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYXBwJykpO1xyXG59KCkpO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vanMvYXBwLmpzXG4gKiovIiwiaW1wb3J0IElyY0NsaWVudCBmcm9tIFwiLi9JcmNDbGllbnQuanNcIjtcclxuaW1wb3J0IHttYWtlVXNlciwgc3BsaXR9IGZyb20gXCIuLi9oZWxwZXJzLmpzXCI7XHJcblxyXG5cclxuLyoqXHJcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhIGZvcm0tYmFja2VkIElSQyBjbGllbnQuXHJcbiAqL1xyXG5jbGFzcyBDbGllbnQge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgYSBuZXcgY2xpZW50IGFuZCB0aGUgZm9ybSB0aGF0IHByb3ZpZGVzIGl0cyBpbnB1dCBhbmQgb3V0cHV0LlxyXG4gICAgICogQHBhcmFtIHtjb250YWluZXJ9IFRoZSBjb250YWluZXIgZWxlbWVudCB0byBhZGQgdGhlIGZvcm0gdG8uXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGNvbnRhaW5lcikge1xyXG4gICAgICAgIHZhciBmb3JtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZm9ybScpO1xyXG4gICAgICAgIGZvcm0uY2xhc3NOYW1lID0gJ2NsaWVudCc7XHJcbiAgICAgICAgdmFyIG91dHB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICAgIG91dHB1dC5jbGFzc05hbWUgPSAnY2xpZW50LW91dHB1dCc7XHJcbiAgICAgICAgb3V0cHV0LmRpc2FibGVkID0gdHJ1ZTtcclxuICAgICAgICBmb3JtLmFwcGVuZENoaWxkKG91dHB1dCk7XHJcbiAgICAgICAgdmFyIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcclxuICAgICAgICBpbnB1dC5jbGFzc05hbWUgPSAnY2xpZW50LWlucHV0JztcclxuICAgICAgICBpbnB1dC5hdXRvZm9jdXMgPSB0cnVlO1xyXG4gICAgICAgIGlucHV0LnBsYWNlaG9sZGVyID0gJ0pPSU4gI2NoYW5uZWwnO1xyXG4gICAgICAgIGZvcm0uYXBwZW5kQ2hpbGQoaW5wdXQpO1xyXG4gICAgICAgIGZvcm0ub25zdWJtaXQgPSAoKSA9PiB0aGlzLnNlbmRNZXNzYWdlKCk7XHJcbiAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGZvcm0pO1xyXG5cclxuICAgICAgICB2YXIgY2xpZW50ID0gbmV3IElyY0NsaWVudCgnY2hhdC5mcmVlbm9kZS5uZXQnLCA2NjY3KTtcclxuICAgICAgICBjbGllbnRcclxuICAgICAgICAgICAgLnN1YnNjcmliZSgnUElORycsIG1zZyA9PiB7XHJcbiAgICAgICAgICAgICAgICBjbGllbnQuc2VuZENvbW1hbmQoJ1BPTkcnLCBtc2cpO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAuc3Vic2NyaWJlKCdOT1RJQ0UnLCBtc2cgPT4ge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlcyA9IHNwbGl0KG1zZyk7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVjaXBpZW50ID0gcmVzWzBdO1xyXG4gICAgICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSByZXNbMV0uc3Vic3RyaW5nKDEpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy53cml0ZU1lc3NhZ2UobWVzc2FnZSk7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC8vIC5zdWJzY3JpYmUoWycwMDEnLCAnMDAyJywgJzAwMyddLCBtc2cgPT4geyAvLyBXZWxjb21lXHJcbiAgICAgICAgICAgIC8vICAgICB2YXIgcmVzID0gc3BsaXQobXNnKTtcclxuICAgICAgICAgICAgLy8gICAgIHZhciBtZXNzYWdlID0gcmVzWzFdLnN1YnN0cmluZygxKTtcclxuICAgICAgICAgICAgLy8gICAgIHRoaXMud3JpdGVNZXNzYWdlKG1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAvLyB9KVxyXG4gICAgICAgICAgICAvLyAuc3Vic2NyaWJlKFsnMDA0JywgJzAwNSddLCBtc2cgPT4geyAvLyBpbmZvXHJcbiAgICAgICAgICAgIC8vICAgICB2YXIgcmVzID0gc3BsaXQobXNnKTtcclxuICAgICAgICAgICAgLy8gICAgIHZhciBtZXNzYWdlID0gcmVzWzFdO1xyXG4gICAgICAgICAgICAvLyAgICAgdGhpcy53cml0ZU1lc3NhZ2UobWVzc2FnZSk7XHJcbiAgICAgICAgICAgIC8vIH0pXHJcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoWyczNTMnLCAnMzY2J10sIG1zZyA9PiB7IC8vIE5BTUVTXHJcbiAgICAgICAgICAgICAgICB2YXIgcmVzID0gc3BsaXQobXNnLCAnICcsIDIpO1xyXG4gICAgICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSByZXNbMl07XHJcbiAgICAgICAgICAgICAgICB0aGlzLndyaXRlTWVzc2FnZShtZXNzYWdlKTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLnN1YnNjcmliZShbJzQzMicsICc0MzMnLCAnNDUxJ10sIG1zZyA9PiB7IC8vIEVSUl9OSUNLTkFNRUlOVVNFXHJcbiAgICAgICAgICAgICAgICB2YXIgcmVzID0gc3BsaXQobXNnKTtcclxuICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlID0gcmVzWzFdO1xyXG4gICAgICAgICAgICAgICAgdGhpcy53cml0ZU1lc3NhZ2UobWVzc2FnZSk7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoWyc3MDQnLCAnNzA1JywgJzcwNiddLCBtc2cgPT4geyAvLyBIRUxQXHJcbiAgICAgICAgICAgICAgICB2YXIgcmVzID0gc3BsaXQobXNnLCAnICcsIDIpO1xyXG4gICAgICAgICAgICAgICAgdmFyIG1zZyA9IHJlc1syXS5zdWJzdHJpbmcoMSkudHJpbSgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG1zZyAhPT0gJycpIHRoaXMud3JpdGVNZXNzYWdlKG1zZyk7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoJ1FVSVQnLCAobXNnLCBwcmUpID0+IHtcclxuICAgICAgICAgICAgICAgIHZhciB1c2VyID0gbWFrZVVzZXIocHJlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMud3JpdGVNZXNzYWdlKHVzZXIuc3BhbiwgYCBoYXMgcXVpdDogJHttc2cuc3Vic3RyaW5nKDEpfWApO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAuc3Vic2NyaWJlKCdKT0lOJywgKG1zZywgcHJlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdXNlciA9IG1ha2VVc2VyKHByZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLndyaXRlTWVzc2FnZSh1c2VyLnNwYW4sIGAgaGFzIGpvaW5lZCAke21zZ31gKTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLnN1YnNjcmliZSgnUEFSVCcsIChtc2csIHByZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdmFyIHVzZXIgPSBtYWtlVXNlcihwcmUpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy53cml0ZU1lc3NhZ2UodXNlci5zcGFuLCBgIGhhcyBsZWZ0ICR7bXNnfWApO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAuc3Vic2NyaWJlKCdOSUNLJywgKG1zZywgcHJlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdXNlciA9IG1ha2VVc2VyKHByZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLndyaXRlTWVzc2FnZSh1c2VyLnNwYW4sIGAgaGFzIGNoYW5nZWQgbmlja25hbWVzIHRvICR7bXNnfWApO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAuc3Vic2NyaWJlKCdQUklWTVNHJywgKG1zZywgcHJlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVzID0gc3BsaXQobXNnKTtcclxuICAgICAgICAgICAgICAgIHZhciBjaGFubmVsID0gcmVzWzBdO1xyXG4gICAgICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSByZXNbMV0uc3Vic3RyaW5nKDEpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHVzZXIgPSBtYWtlVXNlcihwcmUpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy53cml0ZU1lc3NhZ2UoYCR7Y2hhbm5lbH06IGAsIHVzZXIuc3BhbiwgYDogJHttZXNzYWdlfWApO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICBjbGllbnRcclxuICAgICAgICAgICAgLnNlbmRDb21tYW5kKCdQQVNTJywgJ2N1cnRpc3Bhc3N3b3JkJylcclxuICAgICAgICAgICAgLnNlbmRDb21tYW5kKCdOSUNLJywgJ2N1cnRpczUyJylcclxuICAgICAgICAgICAgLnNlbmRDb21tYW5kKCdVU0VSJywgJ2N1cnRpczUyJywgJzAnLCAnKicsICdjdXJ0aXMnKTtcclxuXHJcbiAgICAgICAgdGhpcy5mb3JtID0gZm9ybTtcclxuICAgICAgICB0aGlzLmlucHV0ID0gaW5wdXQ7XHJcbiAgICAgICAgdGhpcy5vdXRwdXQgPSBvdXRwdXQ7XHJcbiAgICAgICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZW5kIGEgbWVzc2FnZSB0byB0aGUgSVJDIHNlcnZlci5cclxuICAgICAqIEBwYXJhbSB7YXJndW1lbnRzfSBUaGUgY29tcG9uZW50cyBvZiB0aGUgbWVzc2FnZSB0byBzZW5kLlxyXG4gICAgICovXHJcbiAgICBzZW5kTWVzc2FnZSgpIHtcclxuICAgICAgICB2YXIgbWVzc2FnZSA9IHRoaXMuaW5wdXQudmFsdWU7XHJcbiAgICAgICAgdGhpcy5pbnB1dC52YWx1ZSA9ICcnO1xyXG5cclxuICAgICAgICB0aGlzLmNsaWVudC5zZW5kTWVzc2FnZShtZXNzYWdlKTtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXcml0ZSBhIG1lc3NhZ2UgdG8gdGhlIGZvcm0gb3V0cHV0LiBBZGRzIGFsbCBhcmd1bWVudHMgdG8gYSBjb250YWluZXJcclxuICAgICAqIGVsZW1lbnQgd2hpY2ggcmVwcmVzZW50cyBhIHNpbmdsZSBtZXNzYWdlLlxyXG4gICAgICogQHBhcmFtIHthcmd1bWVudHN9IFRoZSBjb21wb25lbnRzIG9mIHRoZSBtZXNzYWdlLlxyXG4gICAgICovXHJcbiAgICB3cml0ZU1lc3NhZ2UoKSB7XHJcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiYgYXJndW1lbnRzWzBdID09PSAnJykge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnZW1wdHknKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGVsZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgICAgICBmb3IgKHZhciBpbmQgaW4gYXJndW1lbnRzKSB7XHJcbiAgICAgICAgICAgIHZhciBhcmd1bWVudCA9IGFyZ3VtZW50c1tpbmRdO1xyXG4gICAgICAgICAgICBlbGVtLmFwcGVuZENoaWxkKGFyZ3VtZW50IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgPyBhcmd1bWVudCA6IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGFyZ3VtZW50KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLndyaXRlRWxlbWVudChlbGVtKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFdyaXRlIGEgSFRNTCBlbGVtZW50IHRvIHRoZSBmb3JtIG91dHB1dC5cclxuICAgICAqIEBwYXJhbSB7ZWxlbX0gQSBIVE1MIGVsZW1lbnQuXHJcbiAgICAgKi9cclxuICAgIHdyaXRlRWxlbWVudChlbGVtKSB7XHJcbiAgICAgICAgdmFyIHNjcm9sbFRvQm90dG9tID0gdGhpcy5vdXRwdXQuc2Nyb2xsVG9wICsgdGhpcy5vdXRwdXQuY2xpZW50SGVpZ2h0ICsgMSA+PSB0aGlzLm91dHB1dC5zY3JvbGxIZWlnaHQ7XHJcblxyXG4gICAgICAgIHZhciBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgICAgICBjb250YWluZXIuY2xhc3NOYW1lID0gJ2NsaWVudC1tZXNzYWdlJztcclxuICAgICAgICB2YXIgZGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICAgIGRhdGUuaW5uZXJUZXh0ID0gbmV3IERhdGUoKS50b0xvY2FsZVRpbWVTdHJpbmcoKTtcclxuICAgICAgICBkYXRlLmNsYXNzTmFtZSA9ICdjbGllbnQtbWVzc2FnZS10aW1lc3RhbXAnO1xyXG4gICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChkYXRlKTtcclxuICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoZWxlbSk7XHJcbiAgICAgICAgdGhpcy5vdXRwdXQuYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcclxuXHJcbiAgICAgICAgaWYgKHNjcm9sbFRvQm90dG9tKSB7IHRoaXMub3V0cHV0LnNjcm9sbFRvcCA9IHRoaXMub3V0cHV0LnNjcm9sbEhlaWdodDsgfVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG59XHJcblxyXG4oZnVuY3Rpb24oKSB7XHJcbiAgICBuZXcgQ2xpZW50KGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdhcHAnKSk7XHJcbn0oKSk7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9qcy9jb21wb25lbnRzL0NsaWVudC5qc1xuICoqLyIsImltcG9ydCBTb2NrZXQgZnJvbSAnbmV0JztcclxuaW1wb3J0IHtldmVudCwgc3BsaXR9IGZyb20gJy4uL2hlbHBlcnMuanMnO1xyXG5cclxuXHJcbi8qKlxyXG4gKiBBIGNsYXNzIHJlcHJlc2VudGluZyBhbiBJUkMgY2xpZW50LiBBbGxvd3Mgc2VuZGluZyBhbmQgcmVjZWl2aW5nIG9mIG1lc3NhZ2VzXHJcbiAqIHRvL2Zyb20gYW4gSVJDIHNlcnZlci5cclxuICovXHJcbmNsYXNzIElyY0NsaWVudCB7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSBhIG5ldyBJUkMgY2xpZW50LlxyXG4gICAgICogQHBhcmFtIHtob3N0fSBUaGUgaG9zdG5hbWUgb2YgdGhlIHNlcnZlciB0byBjb25uZWN0IHRvLlxyXG4gICAgICogQHBhcmFtIHtwb3J0fSBUaGUgcG9ydCBudW1iZXIgb2YgdGhlIHNlcnZlciB0byBjb25uZWN0IHRvLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcihob3N0LCBwb3J0KSB7XHJcbiAgICAgICAgdmFyIHNvY2tldCA9IG5ldyBTb2NrZXQoKTtcclxuICAgICAgICBzb2NrZXQuc2V0RW5jb2RpbmcoJ2FzY2lpJyk7XHJcbiAgICAgICAgc29ja2V0LmNvbm5lY3Qoe1xyXG4gICAgICAgICAgICBob3N0OiBob3N0LFxyXG4gICAgICAgICAgICBwb3J0OiBwb3J0XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgc29ja2V0Lm9uKCdkYXRhJywgZGF0YSA9PiB0aGlzLnJlY2VpdmVEYXRhKGRhdGEpKTtcclxuXHJcbiAgICAgICAgdGhpcy5zb2NrZXQgPSBzb2NrZXQ7XHJcbiAgICAgICAgdGhpcy5idWZmZXIgPSAnJztcclxuICAgICAgICB0aGlzLnJlY3ZFdmVudCA9IGV2ZW50KCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTdWJzY3JpYmUgdG8gbWVzc2FnZXMgcmVjZWl2ZWQgYnkgdGhlIElSQyBzZXJ2ZXIuXHJcbiAgICAgKiBAcGFyYW0ge3RhcmdldH0gVGhlIHRhcmdldCBtZXNzYWdlL3MgdG8gc3Vic2NyaWJlIHRvLiBJZiBhIHN0cmluZyxcclxuICAgICAqICAgICBtYXRjaGVzIG1lc3NhZ2VzIG9mIHRoZSBzdXBwbGllZCBjb21tYW5kLiBJZiBhIGxpc3QsIG1hdGNoZXNcclxuICAgICAqICAgICBtZXNzYWdlcyBvZiBhbnkgb2YgdGhlIHN1cHBsaWVkIGNvbW1hbmRzLiBJZiBhIHByZWRpY2F0ZSwgbWF0Y2hlc1xyXG4gICAgICogICAgIG1lc3NhZ2VzIHdob3NlIGNvbW1hbmQgc2F0aXNmaWVzIHRoZSBwcmVkaWNhdGUuXHJcbiAgICAgKiBAcGFyYW0ge2hhbmRsZXJ9IFRoZSBjYWxsYmFjayBmdW5jdGlvbi4gUmVjZWl2ZXMgdGhlIG1lc3NhZ2UsIHByZWZpeCBhbmRcclxuICAgICAqICAgICBjb21tYW5kLlxyXG4gICAgICogQHJldHVybiBBIGNhbGxhYmxlIHRvIHVuc3Vic2NyaWJlLlxyXG4gICAgICovXHJcbiAgICBzdWJzY3JpYmUodGFyZ2V0LCBoYW5kbGVyKSB7XHJcbiAgICAgICAgdmFyIHByZWRpY2F0ZTtcclxuICAgICAgICBzd2l0Y2ggKHR5cGVvZih0YXJnZXQpKSB7XHJcbiAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XHJcbiAgICAgICAgICAgICAgICBwcmVkaWNhdGUgPSAobXNnLCBwcmUsIGNtZCkgPT4gdGFyZ2V0ID09PSBjbWQ7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcclxuICAgICAgICAgICAgICAgIHByZWRpY2F0ZSA9IChtc2csIHByZSwgY21kKSA9PiB0YXJnZXQuaW5jbHVkZXMoY21kKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgcHJlZGljYXRlID0gdGFyZ2V0O1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucmVjdkV2ZW50LnN1YnNjcmliZShoYW5kbGVyLCBwcmVkaWNhdGUpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2VuZCBhIG1lc3NhZ2UgdG8gdGhlIElSQyBzZXJ2ZXIuXHJcbiAgICAgKiBAcGFyYW0ge21lc3NhZ2V9IFRoZSBtZXNzYWdlIHRvIHNlbmQuXHJcbiAgICAgKi9cclxuICAgIHNlbmRNZXNzYWdlKG1lc3NhZ2UpIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhgPDw8ICR7bWVzc2FnZX1gKTtcclxuICAgICAgICB0aGlzLnNvY2tldC53cml0ZShtZXNzYWdlICsgJ1xcclxcbicpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2VuZCBhIGNvbW1hbmQgdG8gdGhlIElSQyBzZXJ2ZXIsIGJ5IGpvaW5pbmcgdGhlIGFycmF5IG9mIGFyZ3VtZW50c1xyXG4gICAgICogd2l0aCBzcGFjZXMuXHJcbiAgICAgKiBAcGFyYW0ge2FyZ3VtZW50c30gVGhlIGFyZ3VtZW50cyB0aGF0IG1ha2UgdXAgdGhlIGNvbW1hbmQuXHJcbiAgICAgKi9cclxuICAgIHNlbmRDb21tYW5kKCkge1xyXG4gICAgICAgIHZhciBhcmdzID0gQXJyYXkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcclxuICAgICAgICB0aGlzLnNlbmRNZXNzYWdlKGFyZ3Muam9pbignICcpKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICByZWNlaXZlRGF0YShkYXRhKSB7XHJcbiAgICAgICAgdGhpcy5idWZmZXIgKz0gZGF0YTtcclxuICAgICAgICB2YXIgaW5kZXg7XHJcbiAgICAgICAgd2hpbGUgKHRoaXMuYnVmZmVyLmxlbmd0aCA+IDAgJiYgKGluZGV4ID0gdGhpcy5idWZmZXIuaW5kZXhPZignXFxuJykpICE9PSAtMSkge1xyXG4gICAgICAgICAgICB2YXIgbWVzc2FnZSA9IHRoaXMuYnVmZmVyLnN1YnN0cmluZygwLCBpbmRleCk7XHJcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyID0gdGhpcy5idWZmZXIuc3Vic3RyaW5nKGluZGV4KzEpO1xyXG4gICAgICAgICAgICB0aGlzLnJlY2VpdmVNZXNzYWdlKG1lc3NhZ2UpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZWNlaXZlTWVzc2FnZShtZXNzYWdlKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coYD4+PiAke21lc3NhZ2V9YCk7XHJcblxyXG4gICAgICAgIHZhciByZXMgPSBzcGxpdChtZXNzYWdlKTtcclxuICAgICAgICB2YXIgdG9rZW4gPSByZXNbMF07XHJcbiAgICAgICAgbWVzc2FnZSA9IHJlc1sxXTtcclxuICAgICAgICB2YXIgcHJlZml4LCBjb21tYW5kO1xyXG4gICAgICAgIGlmICh0b2tlblswXSA9PT0gJzonKSB7XHJcbiAgICAgICAgICAgIHByZWZpeCA9IHRva2VuO1xyXG4gICAgICAgICAgICByZXMgPSBzcGxpdChtZXNzYWdlKTtcclxuICAgICAgICAgICAgY29tbWFuZCA9IHJlc1swXTtcclxuICAgICAgICAgICAgbWVzc2FnZSA9IHJlc1sxXTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBwcmVmaXggPSBudWxsO1xyXG4gICAgICAgICAgICBjb21tYW5kID0gdG9rZW47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnJlY3ZFdmVudC5ub3RpZnkobWVzc2FnZSwgcHJlZml4LCBjb21tYW5kKTtcclxuICAgIH1cclxufVxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vanMvY29tcG9uZW50cy9JcmNDbGllbnQuanNcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJuZXRcIik7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiBleHRlcm5hbCBcIm5ldFwiXG4gKiogbW9kdWxlIGlkID0gM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXHJcbiAqIFNwbGl0IGEgc3RyaW5nIHdpdGggdGhlIGdpdmVuIHNlcGFyYXRvciBhdCBtb3N0IG4gdGltZXMuXHJcbiAqIEBwYXJhbSB7c3RyfSBUaGUgc3RyaW5nIHRvIHNwbGl0LlxyXG4gKiBAcGFyYW0ge3NlcH0gVGhlIHNlcGFyYXRvciB0byBzcGxpdCBvbi5cclxuICogQHBhcmFtIHtufSBUaGUgbWF4aW11bSBudW1iZXIgb2Ygc3BsaXRzIHRvIG1ha2UuXHJcbiAqIEByZXR1cm4gQW4gYXJyYXkgb2Ygc3Vic3RyaW5ncy5cclxuICovXHJcbmZ1bmN0aW9uIHNwbGl0KHN0ciwgc2VwLCBuKSB7XHJcbiAgICBpZiAoc2VwID09PSB1bmRlZmluZWQpIHsgc2VwID0gJyAnOyB9XHJcbiAgICBpZiAobiA9PT0gdW5kZWZpbmVkKSB7IG4gPSAxOyB9XHJcbiAgICB2YXIgaXRlbXMgPSBbXTtcclxuICAgIHdoaWxlIChuLS0gPiAwICYmIHN0ci5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgdmFyIGluZGV4ID0gc3RyLmluZGV4T2Yoc2VwKTtcclxuICAgICAgICB2YXIgaXRlbSA9IHN0ci5zdWJzdHJpbmcoMCwgaW5kZXgpO1xyXG4gICAgICAgIHN0ciA9IHN0ci5zdWJzdHJpbmcoaW5kZXgrc2VwLmxlbmd0aCk7XHJcbiAgICAgICAgaXRlbXMucHVzaChpdGVtKTtcclxuICAgIH1cclxuICAgIGlmIChzdHIubGVuZ3RoID4gMCkgaXRlbXMucHVzaChzdHIpO1xyXG4gICAgcmV0dXJuIGl0ZW1zO1xyXG59XHJcblxyXG4vKipcclxuICogQ3JlYXRlIGEgbmV3IGV2ZW50LiBUaGUgZXZlbnQgaGFzIGEgc3Vic2NyaWJlIG1ldGhvZCBhbmQgYSBub3RpZnkgbWV0aG9kLlxyXG4gKlxyXG4gKiBUaGUgc3Vic2NyaWJlIG1ldGhvZCByZXR1cm5zIGEgY2FsbGFibGUgd2hpY2ggd2lsbCB1bnN1YnNjcmliZSB3aGVuIGNhbGxlZCxcclxuICogYW5kIGNhbiBhbHNvIGhhdmUgaXRzIHN1YnNjcmliZSBtZXRob2QgY2FsbGVkIHRvIG1ha2UgZnVydGhlciBzdWJzY3JpcHRpb25zLlxyXG4gKiBUaGUgc3Vic2NyaWJlIG1ldGhvZHMgdGFrZSB0d28gZnVuY3Rpb24gaGFuZGxlcywgdGhlIGZpcnN0IGlzIHRoZSBjYWxsYmFja1xyXG4gKiB3aGljaCBpcyBjYWxsZWQgd2hlbiB0aGUgZXZlbnQgaXMgbm90aWZpZWQsIHRoZSBzZWNvbmQgaXMgYSBwcmVkaWNhdGUgd2hpY2hcclxuICogbXVzdCByZXR1cm4gdHJ1ZSBpZiB0aGUgY2FsbGJhY2sgaXMgdG8gYmUgaW52b2tlZC4gVGhlIHNlY29uZCBhcmd1bWVudCBpc1xyXG4gKiBvcHRpb25hbCwgaWYgbWlzc2luZyB0aGUgY2FsbGJhY2sgaXMgYWx3YXlzIGNhbGxlZC5cclxuICpcclxuICogVGhlIG5vdGlmeSBtZXRob2QgdGFrZXMgYW55IG51bWJlciBvZiBhcmd1bWVudHMgYW5kIG5vdGlmaWVzIGFsbCBzdWJzY3JpYmVyc1xyXG4gKiBieSBjYWxsaW5nIHRoZSBwcmVkaWNhdGUgYW5kIGNhbGxiYWNrIGZ1bmN0aW9ucyB3aXRoIHRoZSBzdXBwbGllZCBhcmd1bWVudHMuXHJcbiAqXHJcbiAqIEByZXR1cm4gQSBuZXcgZXZlbnQuXHJcbiAqL1xyXG5mdW5jdGlvbiBldmVudCgpIHtcclxuICAgIHZhciBzdWJzY3JpYmVycyA9IHt9O1xyXG4gICAgdmFyIG5leHRJZCA9IDA7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHN1YnNjcmliZTogZnVuY3Rpb24gKGhhbmRsZXIsIHByZWRpY2F0ZSkge1xyXG4gICAgICAgICAgICB2YXIgaWRzID0gW107XHJcbiAgICAgICAgICAgIHZhciB1bnN1YnNjcmliZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpbmQgaW4gaWRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHN1YnNjcmliZXJzW2lkc1tpbmRdXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdW5zdWJzY3JpYmVyLnN1YnNjcmliZSA9IGZ1bmN0aW9uIChoYW5kbGVyLCBwcmVkaWNhdGUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBpZCA9IG5leHRJZCsrO1xyXG4gICAgICAgICAgICAgICAgaWRzLnB1c2goaWQpO1xyXG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlcnNbaWRdID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZXI6IGhhbmRsZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgcHJlZGljYXRlOiBwcmVkaWNhdGUgfHwgKCgpID0+IHRydWUpXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHVuc3Vic2NyaWJlci5zdWJzY3JpYmUoaGFuZGxlciwgcHJlZGljYXRlKTtcclxuICAgICAgICAgICAgcmV0dXJuIHVuc3Vic2NyaWJlcjtcclxuICAgICAgICB9LFxyXG4gICAgICAgIG5vdGlmeTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpZCBpbiBzdWJzY3JpYmVycykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHN1YnNjcmliZXIgPSBzdWJzY3JpYmVyc1tpZF07XHJcbiAgICAgICAgICAgICAgICBpZiAoc3Vic2NyaWJlci5wcmVkaWNhdGUuYXBwbHkobnVsbCwgYXJndW1lbnRzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZXIuaGFuZGxlci5hcHBseShudWxsLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFBhcnNlIHRoZSBnaXZlbiB1c2VyIG1hc2sgdG8gY3JlYXRlIGEgdXNlciBvYmplY3QuXHJcbiAqIEBwYXJhbSB7bWFza30gVGhlIHVzZXIgbWFzay5cclxuICogQHJldHVybiBBIHVzZXIgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG1hc2ssIG5pY2ssIHVzZXIsIGRvbWFpbiBhbmQgYSBIVE1MXHJcbiAqICAgICBzcGFuLlxyXG4gKi9cclxuZnVuY3Rpb24gbWFrZVVzZXIobWFzaykge1xyXG4gICAgdmFyIHJlcyA9IHNwbGl0KG1hc2ssICchJyk7XHJcbiAgICB2YXIgbmljayA9IHJlc1swXS5zdWJzdHJpbmcoMSk7XHJcbiAgICByZXMgPSBzcGxpdChyZXNbMV0sICdAJyk7XHJcbiAgICB2YXIgc3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcclxuICAgIHNwYW4uaW5uZXJUZXh0ID0gbmljaztcclxuICAgIHNwYW4uY2xhc3NOYW1lID0gJ3Rvb2x0aXAnO1xyXG4gICAgdmFyIHRvb2x0aXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XHJcbiAgICB0b29sdGlwLmlubmVyVGV4dCA9IG1hc2s7XHJcbiAgICB0b29sdGlwLmNsYXNzTmFtZSA9ICd0b29sdGlwdGV4dCc7XHJcbiAgICBzcGFuLmFwcGVuZENoaWxkKHRvb2x0aXApO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBtYXNrOiBtYXNrLFxyXG4gICAgICAgIG5pY2s6IG5pY2ssXHJcbiAgICAgICAgdXNlcjogcmVzWzBdLnN1YnN0cmluZygxKSxcclxuICAgICAgICBkb21haW46IHJlc1sxXSxcclxuICAgICAgICBzcGFuOiBzcGFuXHJcbiAgICB9O1xyXG59XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9qcy9oZWxwZXJzLmpzXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==